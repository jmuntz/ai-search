<!DOCTYPE html>
<html>
<head>
	<title>MineSearcher</title>

	<link href="https://fonts.googleapis.com/css?family=Baloo+Thambi|Istok+Web|Lemonada|Tinos:700i|Yellowtail" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Roboto:300" rel="stylesheet">

	<style type="text/css">
		
		body {
			font-family: "Roboto";
			font-size: 16px;
		}

		h1, h2, h3, h4, h5 {
			font-family: "Lemonada";
		}

		canvas {
			/*border: 2px solid grey;*/
		}

		#settings {
			position: fixed;
			left: 50%;
			top: 0;
			width: 50%;
			height: auto;
			background: #eee;
			padding: 10px 15px;
			overflow: scroll;
		}

		#details {
			position: fixed;
			left: 50%;
			top: 100px;
			width: 50%;
			height: 95%;
			background: #eee;
			padding: 10px 15px;
			overflow: scroll;
		}

		#controls {
			position: fixed;
		    bottom: 0;
		    left: 0;
		    background: #338fe4;
		    border: 0;
		    border-bottom: 2px solid #2c7bc4;
		}

		#controls button {
		    padding: 10px 15px;
			background: transparent;
			border: 0;
			color: white;
			outline: none;
		}

		#controls button:hover {
			background: rgba(0, 0, 0, 0.2);
			cursor: pointer;
		}


	</style>
</head>
<body>

<h1>MineSearcher</h1>

	<canvas id="canvas" height="800" width="800"></canvas>

	<div id="controls">
		<button id="render" onclick="BFS.init()">Start</button>
		<button id="newMinefield" onclick="controller.init()">New Minefield</button>
	</div>
	
	<div id="settings"></div>
	<div id="details"></div>

</body>



<script src="bfs.js"></script>

<script>
	

model = {
	blockSize: 		15,
	blockGap: 		2,
	minefieldSize: 	40,
	blockDensity: 	0.2,
	searchSpeed: 	0,
	blocks: 		[],
	entry: 			[],
	exit: 			[],
}







controller = {

	init: function() {
		this.generateBlocks();	
		view.init();
	},

	generateBlocks: function() {
		model.blocks = [];

		for (x = 0; x < model.minefieldSize; x++) {
			for (y = 0; y < model.minefieldSize; y++) {
				model.blocks.push(new Block(x, y, Math.random() < model.blockDensity, this.isWall(x, y, model.minefieldSize)));
			}
		} this.addExits();
	},

	addExits: function() {

		// Generate random entry/exit points
		entry  	= [this.getRandomIntInclusive(1, model.minefieldSize -2), 0];
		exit 	= [this.getRandomIntInclusive(1, model.minefieldSize -2), model.minefieldSize -1];

		for (var i = 0; i < model.blocks.length; i++) {
			if ((model.blocks[i].x == entry[0]) && (model.blocks[i].y == entry[1])) {
				model.blocks[i].isEntry = true; 
				model.blocks[i].isWall = false; 
				break;
			}
		}

		for (var i = 0; i < model.blocks.length; i++) {
			if ((model.blocks[i].x == exit[0]) && (model.blocks[i].y == exit[1])) {
				model.blocks[i].isExit = true; 
				model.blocks[i].isWall = false; 
				break;
			}
		}

		model.entry = entry;
		model.exit = exit;
	},

	getBlocks: function() {
		return model.blocks;
	},

	getEntry: function() {
		return model.entry;
	},

	getSettings: function() {
		return settings = {
			blockSize:  	model.blockSize,
			blockGap:  		model.blockGap,
			minefieldSize:  model.minefieldSize,
			blockDensity:  	model.blockDensity,
			searchSpeed: 	model.searchSpeed
		}
	},

	getRandomIntInclusive: function(min, max) {
		min = Math.ceil(min);
		max = Math.floor(max);
		return Math.floor(Math.random() * (max - min + 1)) + min;
	},

	isWall: function(x, y, minefieldSize) {
		return ((x == 0) || (x == model.minefieldSize -1) || (y == 0) || y == (model.minefieldSize -1));
	}
}





BFS = {
	init: function() {
		this.blocks 		= controller.getBlocks();
		this.list			= [];
		this.exploredList 	= [];
		this.settings 		= controller.getSettings();

		// Find the entrance and add the node to list 
		// so we can get started
		for (var i = 0; i < this.blocks.length; i++) {
			if (this.blocks[i].isEntry) {
				this.list.push(this.blocks[i]);
				break;
			}
		}

		this.run();
	},



	// LEFT > DOWN > RIGHT > UP
	explore: function(currentBlock) {
		if (this.canMoveLeft(currentBlock)) {
			child = this.fetchBlock(currentBlock.x - 1, currentBlock.y);
			if (!child.queued) {
				child.parent = currentBlock;
				currentBlock.children.push(child);
				this.list.push(child);
				child.queued = true;
			}
		}  

		if (this.canMoveDown(currentBlock)) {
			child = this.fetchBlock(currentBlock.x, currentBlock.y - 1);
			if (!child.queued) {
				child.parent = currentBlock;
				currentBlock.children.push(child);
				this.list.push(child);
				child.queued = true;
			}
		}  

		if (this.canMoveRight(currentBlock)) {
			child = this.fetchBlock(currentBlock.x + 1, currentBlock.y);
			if (!child.queued) {
				child.parent = currentBlock;
				currentBlock.children.push(child);
				this.list.push(child);
				child.queued = true;
			}
		} 

		if (this.canMoveUp(currentBlock)) {
			child = this.fetchBlock(currentBlock.x, currentBlock.y + 1);
			if (!child.queued) {
				child.parent = currentBlock;
				currentBlock.children.push(child);
				this.list.push(child);	
				child.queued = true;
			}
		} 

		this.exploredList.push(currentBlock);
		currentBlock.explored = true;
	},

	fetchBlock: function(x, y) {
		for (var i = 0; i < this.blocks.length; i++) {
			if ((this.blocks[i].x == x ) && (this.blocks[i].y == y )) 
				return this.blocks[i];
		}
	},

	canMoveUp: function(currentBlock) {
		return this.validMove(currentBlock.x, currentBlock.y + 1);
	},

	canMoveDown: function(currentBlock) {
		return this.validMove(currentBlock.x, currentBlock.y - 1);
	},
	
	canMoveLeft: function(currentBlock) {
		return this.validMove(currentBlock.x -1, currentBlock.y);
	},
		
	canMoveRight: function(currentBlock) {
		return this.validMove(currentBlock.x + 1, currentBlock.y);
	},

	validMove: function(x, y) {
		for (var i = 0; i < this.blocks.length; i++) {
			if ((this.blocks[i].x == x ) && 
				(this.blocks[i].y == y ) &&
				(!this.blocks[i].isWall) &&
				(!this.blocks[i].isMine) &&
				(!this.blocks[i].explored))
			return true;
		} return false;
	},

	printList: function(list) {
		for (var i = 0; i < list.length; i++) {
			console.log(list[i].explored);
			console.log("[" + list[i].x + ", " + list[i].y + "]:" + list[i].queued);

		}	

		console.log("--------");
	},

	getTree: function(block) {

	},

	run: function() {

		if (currentBlock = this.list.shift()) {
			console.log("SPEED: " + this.settings.searchSpeed);

			if (currentBlock.explored) {
				while (currentBlock.explored) 
					currentBlock = this.list.shift();
			}

			view.renderGreen(currentBlock);
			
			send(this.exploredList.length);

			if (!currentBlock.isExit) {

				
				view.renderTree(this.exploredList);
				this.explore(currentBlock);

				// Sleep it so it's chill

				this.printList(this.list);
				setTimeout(function() {
					BFS.run();
				}, this.settings.searchSpeed);

			} else {
				console.log("We found the exit!");
				return;
				complete = true;
				console.log(currentBlock);
			}

				
			
		}

	}
}










view = {
	init: function() {
		console.log("View initializing.");
		
		this.canvas 	= document.getElementById("canvas");
		this.ctx	 	= this.canvas.getContext('2d');
		this.settings 	= controller.getSettings();
		
		this.render();
		
	},

	render: function() {
		console.log("View rendering.");

		var ctx 		= this.ctx;
		var settings 	= this.settings;
		var blocks  	= controller.getBlocks();
		
		for (var i = 0; i < blocks.length; i++) {
		
			if (blocks[i].isMine) {
				ctx.fillStyle = "red";
			} else if ((blocks[i].isEntry) || (blocks[i].isExit)) {
				ctx.fillStyle = "#a858ff";
			} else if (blocks[i].isWall) {
				ctx.fillStyle = "black";
			} else ctx.fillStyle = "#6d6ddf";

			ctx.fillRect(
				blocks[i].x * (settings.blockSize + settings.blockGap), 
				blocks[i].y * (settings.blockSize + settings.blockGap), 
				settings.blockSize,
				settings.blockSize
			);
		}
	},

	renderGreen: function(block) {
		var settings  = this.settings;
		var ctx 	  = this.ctx;

		ctx.fillStyle = "green";

		ctx.fillRect(
			block.x * (settings.blockSize + settings.blockGap), 
			block.y * (settings.blockSize + settings.blockGap), 
			settings.blockSize,
			settings.blockSize
		);
	},

	renderTree: function(tree) {
		var settings  = this.settings;
		var ctx 	  = this.ctx;

		for (var i = 0; i < tree.length; i++) {
			ctx.fillStyle = "black";
			ctx.fillRect(
				tree[i].x * (settings.blockSize + settings.blockGap), 
				tree[i].y * (settings.blockSize + settings.blockGap), 
				settings.blockSize,
				settings.blockSize
			);
			
			for (var k = 0; k < tree[i].children.length; k++) {
				ctx.fillStyle = "orange";
				ctx.fillRect(
					tree[i].children[k].x * (settings.blockSize + settings.blockGap), 
					tree[i].children[k].y * (settings.blockSize + settings.blockGap), 
					settings.blockSize,
					settings.blockSize
				);
			}
		}
	},

	renderBlock: function(block, colour) {
		this.ctx.fillStyle = colour;
		this.ctx.fillRect(
			block[i].x * (this.settings.blockSize + this.settings.blockGap), 
			block[i].y * (this.settings.blockSize + this.settings.blockGap), 
			this.settings.blockSize,
			this.settings.blockSize
		);
	},

	renderFinalPath: function(exitBlock) {

	},
}









function Block(x, y, isMine = false, isWall = false) {
  	this.x = x;
  	this.y = y;
  	this.explored = false;
  	this.children = [];

  	if (isWall) 
  		isMine = false;
  	
  	this.isMine = isMine;
  	this.isWall = isWall;
}	



function send(msg) {
	var details = document.getElementById("details");
	details.innerHTML += "<br>" + msg;
}





controller.init();



</script>
</html>